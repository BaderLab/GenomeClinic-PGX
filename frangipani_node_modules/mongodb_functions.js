/* 
 * MongoDB interface for node server.
 * @author Ron Ammar
 */

var MongoClient= require("mongodb").MongoClient;
var Promise = require("bluebird");
var assert= require("assert");
var dbConstants= require("./mongodb_constants");


/* Default DB parameters. */
var dbURL= undefined;
var db= undefined; // MongoDB connection db object (once connected)


/* Connect to the DB using default parameters.
 * If connection has already been initialized, but closed, it is opened.
 * If connection is already open, the connection pool is refereshed.
 * Returns a promise if connection does not exist, null otherwise. */
var connect= function() {
	// if DB exists and is open/closed, refresh/open the connection pool
	if (db) {
		db.open();
		return null;
	}

	dbURL= "mongodb://" + dbConstants.DB_HOST + ":" + dbConstants.DB_PORT + "/" + dbConstants.DB_NAME;

	var promise= new Promise(function(resolve, reject) {
		MongoClient.connect(dbURL, function(err, db) {
			if (err) {
				reject(err);
			}
			resolve(db);
		});
	});
	return promise;
};


/* Close the DB connection. */
var closeConnection= function(callback) {
	db.close(callback);
};


/* Return the count of documents matching the query.
 * Returns a promise. */
var count= function(collectionName, query) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).count(query, function(err, count){
			if (err) {
				reject(err);
			}
			resolve(count);
		});
	});
	return promise;
};


/* Insert a document into a collection.
 * Returns a promise. */
var insert= function(collectionName, doc) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(doc) == "[object Object]",
		"Invalid document");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).insert(doc, {}, function(err, result) {
			if (err) {
				reject(err);
			}
			resolve(result);
		});
	});
	return promise;
}


/* Create index for a specific field in a collection.
 * spec format example: {a:1, b:-1}, a in ascending index order, b in descending
 * options format example: {unique: true} to ensure that the index is unique
 * Returns a promise. */
var createIndex= function(collectionName, spec, options) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(spec) == "[object Object]",
		"Invalid spec");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).createIndex(spec, options, function(err, result) {
			if (err) {
				reject(err);
			}
			resolve(result);
		});
	});
	return promise;	
};


/* Create the collections required for an initialized DB.
 * Returns a promise. */
var createInitCollections= function() {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	var promise= new Promise(function(resolve, reject) {
		var currentDocument= undefined;

		currentDocument= {};
		currentDocument[dbConstants.CURRENT_PATIENT_INDEX_FIELD]= 1;

		// Create a patient collection and index by unique identifiers.
		insert(dbConstants.ADMIN_COLLECTION_ID, currentDocument)
			.then(function(result) {
				// Patient IDs are unique.
				currentDocument= {};
				currentDocument[dbConstants.PATIENT_ID_FIELD]= 1;  // index in ascending order
				return createIndex(dbConstants.PATIENTS_COLLECTION_ID, currentDocument, {unique: true});
			}).then(function(result){
				// Collection IDs are also unique
				currentDocument= {};
				currentDocument[dbConstants.COLLECTION_ID_FIELD]= -1;  // index in descending order
				return createIndex(dbConstants.PATIENTS_COLLECTION_ID, currentDocument, {unique: true});
			}).then(function(result) {
				resolve();
			}).catch(function(err) {
				reject(err);
			});
	});
	return promise;
};


/* Find a single document based on the query. 
 * Returns a promise. */
var findOne= function(collectionName, query) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(query) == "[object Object]",
		"Invalid query");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).findOne(query, function(err, doc) {
			if (err) {
				reject(err);
			}
			resolve(doc);
		});
	});
	return promise;	
};


/* Update documents based on the query selector with the doc specifying which 
 * fields to update.
 * Returns a promise. */
var update= function(collectionName, query, doc) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(query) == "[object Object]",
		"Invalid query");
	assert(Object.prototype.toString.call(doc) == "[object Object]",
		"Invalid update document");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).update(query, doc, function(err, resultDoc) {
			if (err) {
				reject(err);
			}
			resolve(resultDoc);
		});
	});
	return promise;
};


/* Create a patient with the input patient ID.
 * Returns a promise which resolves to the new patient collection ID. */
var addPatient= function(patientID) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	var currentPatientCollectionID= undefined;

	var promise= new Promise(function(resolve, reject) {
		/* Get most recent patient collection ID integer from the admin table
		 * and increment it. */
		findOne(dbConstants.ADMIN_COLLECTION_ID, {})
			.then(function(doc) {
				currentPatientCollectionID= doc[dbConstants.CURRENT_PATIENT_INDEX_FIELD];
				// Add new patient
				currentDocument= {};
				currentDocument[dbConstants.PATIENT_ID_FIELD]= patientID;
				currentDocument[dbConstants.COLLECTION_ID_FIELD]= "p" + currentPatientCollectionID;
				return insert(dbConstants.PATIENTS_COLLECTION_ID, currentDocument);
			}).then(function(result) {
				// Increment patient collection ID only after insert is done
				var currentDocument= {};
				currentDocument[dbConstants.CURRENT_PATIENT_INDEX_FIELD]= 1;  // increment by 1
				return update(dbConstants.ADMIN_COLLECTION_ID, {}, {$inc: currentDocument});
			}).then(function(result) {
				resolve("p" + currentPatientCollectionID);
			}).catch(function(err) {
				reject(err);
			});
	});
	return promise;
};


/* Connect to the DB and initialize it using defaults if the DB has not been
 * initialized already. */
var connectAndInitializeDB= function() {
	// Connect to MongoDB
	connect().then(function(result) {
		db= result;
		console.log("Connected to MongoDB at " + dbURL);

		/* Check if the "FrangipaniDB" DB already exists. If it doesn't, 
		 * we need to intialize the DB. */
		 count(dbConstants.SYSTEM_NAMESPACES).then(function(result) {
		 	if (!result) { // # of collections in DB is 0
		 		console.log("Initializing FrangipaniDB.");
		 		createInitCollections()
		 			.then(function(result) {
		 				return addPatient("test_first");
	 				}).then(function(newCollectionID) {
	 					console.log("Sample patient added with collection ID \"" + newCollectionID + "\"");
	 				}).catch(function(err) {
	 					console.error(err.toString);
	 					console.error(err.stack);
	 				});
		 	} else {
		 		console.log("FrangipaniDB has already been initialized.");
		 	}

		 }).catch(function(err) {
		 	console.error(err.toString());
			console.error(err.stack);
		 });

	}).catch(function(err) {
		console.error(err.toString());
		console.error(err.stack);
	});
};


/* Assign desired objects to exports. */ 
exports.connectAndInitializeDB= connectAndInitializeDB;
exports.closeConnection= closeConnection;


















