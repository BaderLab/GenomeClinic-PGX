/* 
 * MongoDB interface for node server.
 * @author Ron Ammar
 */

var MongoClient= require("mongodb").MongoClient;
var Promise = require("bluebird");
var assert= require("assert");
var dbConstants = require("./mongodb_constants");
var bcrypt = require("bcrypt-nodejs");
var randomstring = require("just.randomstring");
var pgx= require("./pgx/pgx_haplotypes");

/* Default DB parameters. */
var dbURL= undefined;
var db= undefined; // MongoDB connection db object (once connected)


/* Connect to the DB using default parameters.
 * If connection has already been initialized, but closed, it is opened.
 * If connection is already open, the connection pool is refereshed.
 * Returns a promise if connection does not exist, null otherwise. */
var connect= function() {
	// if DB exists and is open/closed, refresh/open the connection pool
	if (db) {
		db.open();
		return null;
	}

	dbURL= "mongodb://" + dbConstants.DB_HOST + ":" + dbConstants.DB_PORT + "/" + dbConstants.DB_NAME;

	var promise= new Promise(function(resolve, reject) {
		MongoClient.connect(dbURL, function(err, db) {
			if (err) {
				reject(err);
			}
			resolve(db);
		});
	});
	return promise;
};


/* Close the DB connection. */
var closeConnection= function(callback) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first
	db.close(callback);
};


/* Return the count of documents matching the query.
 * Returns a promise. */
var count= function(collectionName, query) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).count(query, function(err, count){
			if (err) {
				reject(err);
			}
			resolve(count);
		});
	});
	return promise;
};


/* Insert a document into a collection.
 * Returns a promise. */
var insert= function(collectionName, doc) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(doc) == "[object Object]",
		"Invalid document");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).insert(doc, {}, function(err, result) {
			if (err) {
				reject(err);
			}
			resolve(doc);
		});
	});
	return promise;
};


/* Insert up to 1000 documents at once into a collection.
 * Takes one Object with two paramters arguments:
 * tablename: tablename
 * documents: {object to insert}
 * Returns a promise. */
var insertMany = function(options){
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(options) == "[object Object]",
		"Invalid Options");

	var promise = new Promise(function(resolve,reject){
		if(!options.collectionName)
			reject(new ReferenceError("No Table Name Provided"));
		//if(options.documents.length > 100)
		//		reject(new Error("Must contain less then 1000 documents"))


		db.collection(options.collectionName,function(err,collection){
			var bulk = collection.initializeOrderedBulkOp();
			for (var i = 0; i < options.documents.length; i++){
				bulk.insert(options.documents[i]);
			}
			bulk.execute(function(err,doc){
				if(err){
					reject(err)
				} else {
					resolve(doc);
				}
			});
		});
	});
	return promise;
};


/* Create index for a specific field in a collection.
 * spec format example: {a:1, b:-1}, a in ascending index order, b in descending
 * options format example: {unique: true} to ensure that the index is unique
 * Returns a promise. */
var createIndex= function(collectionName, spec, options) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(spec) == "[object Object]",
		"Invalid spec");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).createIndex(spec, options, function(err, result) {
			if (err) {
				reject(err);
			}
			resolve(result);
		});
	});
	return promise;	
};


/* Create the collections required for an initialized DB.
 * Returns a promise. */
var createInitCollections= function() {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	var promise= new Promise(function(resolve, reject) {
		var currentDocument= undefined;

		currentDocument= {};
		currentDocument[dbConstants.CURRENT_PATIENT_INDEX_FIELD]= 1;
		currentDocument[dbConstants.CURRENT_PANEL_INDEX_FIELD]= 1;
		// when the DB is first initialized, the server is not configured
		currentDocument[dbConstants.SERVER_CONFIGURED_ID_FIELD]= false;

		// Create a patient collection and index by unique identifiers.
		// Do the same for panel collections.
		insert(dbConstants.ADMIN_COLLECTION_ID, currentDocument)
			.then(function(result) {
				// Patient IDs are unique.
				currentDocument= {};
				currentDocument[dbConstants.PATIENT_ID_FIELD]= 1;  // index in ascending order
				return createIndex(dbConstants.PATIENTS_COLLECTION_ID, currentDocument, {unique: true});
			})
			.then(function(result){
				// Patient Collection IDs are also unique
				currentDocument= {};
				currentDocument[dbConstants.COLLECTION_ID_FIELD]= -1;  // index in descending order
				return createIndex(dbConstants.PATIENTS_COLLECTION_ID, currentDocument, {unique: true});
			})
			.then(function(result){
				var currentDocument = {};
				currentDocument[dbConstants.USER_ID_FIELD]=-1;
				return createIndex(dbConstants.USER_COLLECTION_ID,currentDocument,{unique:true})
			})
			.then(function(result) {
				// Panel IDs are unique.
				currentDocument= {};
				currentDocument[dbConstants.PANEL_ID_FIELD]= 1;  // index in ascending order
				return createIndex(dbConstants.PANELS_COLLECTION_ID, currentDocument, {unique: true});
			})
			.then(function(result){
				// Panel Collection IDs are also unique
				currentDocument= {};
				currentDocument[dbConstants.COLLECTION_ID_FIELD]= -1;  // index in descending order
				return createIndex(dbConstants.PANELS_COLLECTION_ID, currentDocument, {unique: true});
			})
			.then(function(result){
				//project_id field should be unique
				currentDocument = {}
				currentDocument[dbConstants.PROJECT_ID_FIELD] = 1; // index in ascending order
				return createIndex(dbConstants.PROJECT_COLLECTION_ID, currentDocument,{unique:true}); 
			})
			.then(function(result) {
				resolve();
			})
			.catch(function(err) {
				reject(err);
			});
	});
	return promise;
};


/* general find query to find All documents matching string. 
 * Returns a promise. */
var find= function(collectionName, query, fields, options) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(query) == "[object Object]",
		"Invalid query");

	if (options){
		if(options == {})
			options = undefined;

		else if (options)
			assert(Object.prototype.toString.call(options) == "[object Object]",
				"Invalid Options");
	}

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName)
		.find(query, fields, options)
		.toArray(function(err, doc) {
			if (err) {
				reject(err);
			}
			resolve(doc);
		});
	});
	return promise;	
};


/* Find a single document based on the query. 
 * Returns a promise. */
var findOne= function(collectionName, query) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(query) == "[object Object]",
		"Invalid query");
	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).findOne(query,function(err, doc) {
			if (err) {
	
				reject(err);
			}
			resolve(doc);
		});
	});
	return promise;	
};


/* Find all the patients in the 'patients' collection.
 * Returns a promise that returns an array of elements corresponding to All
 * the patient_id's*/
var findAllPatientIds=function(){
	assert.notStrictEqual(db, undefined); // ensure we're connected first
	var collectionName = dbConstants.PATIENTS_COLLECTION_ID;
	var options = {'_id':0};
	options[dbConstants.PATIENT_ID_FIELD]=1;	
	return find(collectionName, {}, {}, options);
};


/* find all the patients in the patient collection and return an array
 * corresponding to the entire document of each patient.
 * If readyOnly == true, return only fully uploaded patients.
 * To get output sorted by date and time(newest patient records first), do:
 * options == {sort: {"date": -1, "time": -1}} */
var findAllPatients=function(readyOnly, options){
	assert.notStrictEqual(db, undefined); // ensure we're connected first
	var collectionName = dbConstants.PATIENTS_COLLECTION_ID;
	var query= {};
	var fields = {'_id': 0};
	if (readyOnly) {
		query["ready"]= true;
	}
	return find(collectionName, query, fields, options);
};



var findAllProjects = function(){
	assert.notStrictEqual(db, undefined);
	var query = {};
	var resultArray;

	return find(dbConstants.PROJECT_COLLECTION_ID,query).then(function(result){
		resultArray = result;
		return resultArray
	}).each(function(doc,index){
		var query = {};
		query[dbConstants.PROJECT_ARRAY_FIELD] = doc[dbConstants.PROJECT_ID_FIELD];
		return count('patients',query).then(function(result){
			resultArray[index]["numPatients"] = result;
		})
	}).then(function(){
		return resultArray;
	});

}	


var addProject = function(options){
	assert.notStrictEqual(db,undefined);
	assert(Object.prototype.toString.call(options) == '[object Object]',"Invalid options")
	//project info should have patient_id, details, and for future use, allowed users
	var projectInfo = options['project'];
	var projectInfo['date'] = new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '')
	var patientTags = options['patients'];

	return insert(dbConstants.PROJECT_COLLECTION_ID, projectInfo).then(function(result){
		if (patientTags) {
			return Promise.each(patientTags,function(patient){
				return addProjectToPatient(projectInfo[dbConstants.PROJECT_ID_FIELD],patient)
			});
		}	
	});
}


var addProjectToPatient = function(project,patient){
	assert.notStrictEqual(db,undefined);
	assert(Object.addProjectToPatient.toString.call(project) == "[object String]", "Invalid Project Name");
	assert(Object.addProjectToPatient.toString.call(patient) == "[object String]", "Invalid Patient Name");

	var query = {}
	query[dbConstants.PATIENT_ID_FIELD] = patient;
	doc = {};
	doc[dbConstants.PROJECT_ARRAY_FIELD] = project;
	doc = {$addToSet:doc};
	return update(dbConstants.PATIENTS_COLLECTION_ID, query, doc)
}

/* count the number of entries in the specified collection
 */
var count = function(collectionName, query){

	if (!query){
		var query = {}
	}

	var promise = new Promise(function(resolve,reject){
		assert.notStrictEqual(db, undefined);
		assert(Object.prototype.toString.call(query) == '[object Object]',"Invalid query")
		assert(Object.prototype.toString.call(collectionName) == "[object String]",
			"Invalid collection");
		db.collection(collectionName,function(err,collection){
			collection.count(query,function(err,result){
				if (err)
					reject(err)
				else
					resolve(result);
			});	
		});
	});
	return promise;
};

/* Update documents based on the query selector with the doc specifying which 
 * fields to update.
 * Returns a promise. */
var update= function(collectionName, query, doc, options) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid collection");
	assert(Object.prototype.toString.call(query) == "[object Object]",
		"Invalid query");
	assert(Object.prototype.toString.call(doc) == "[object Object]",
		"Invalid update document");
	if (options)
		assert(Object.prototype.toString.call(options) == "[object Object]",
		"Invalid update options");

	var promise= new Promise(function(resolve, reject) {
		db.collection(collectionName).update(query, doc, options, function(err, resultDoc) {
			if (err) {
				reject(err);
			}
			resolve(resultDoc);
		});
	});
	return promise;
};


/* Create a patient with the input patient ID.
 * Returns a promise which resolves to the new patient collection ID. */
var addPatient= function(options) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first
	var currentPatientCollectionID= undefined;

	var promise= new Promise(function(resolve, reject) {
		/* Get most recent patient collection ID integer from the admin table
		 * and increment it. */
		findOne(dbConstants.ADMIN_COLLECTION_ID, {})
			.then(function(doc) {
				currentPatientCollectionID= doc[dbConstants.CURRENT_PATIENT_INDEX_FIELD];
				// Add new patient
				if (typeof options === 'object'){
					currentDocument = options;
				} else { 
					currentDocument= {};
					currentDocument[dbConstants.PATIENT_ID_FIELD] = options;
				}

				if (currentDocument[dbConstants.PATIENT_ID_FIELD]===undefined)
					throw new ReferenceError("No Patient ID provided");
					

				currentDocument[dbConstants.COLLECTION_ID_FIELD]= "p" + currentPatientCollectionID;
				return insert(dbConstants.PATIENTS_COLLECTION_ID, currentDocument);
			}).then(function(result) {
				// Increment patient collection ID only after insert is done
				var currentDocument= {};
				currentDocument[dbConstants.CURRENT_PATIENT_INDEX_FIELD]= 1;  // increment by 1
				return update(dbConstants.ADMIN_COLLECTION_ID, {}, {$inc: currentDocument});
			}).then(function(result) {
				resolve({newCollection:"p" + currentPatientCollectionID, document:currentDocument});
			}).catch(function(err) {
				console.log(err);
				reject(err);
			});
	});
	return promise;
};


/* find and remove a patient where options are the query to submit
 * returns a promise */
var removePatient = function(options){
	assert.notStrictEqual(db, undefined); // ensure we're connected first

	// validate input
	assert(Object.prototype.toString.call(options) == "[object Object]",
		"Invalid Options");

	var promise = new Promise(function(resolve,reject){
		db.collection('patients',function(err,coll){
			coll.findAndRemove(options,['patient_id',1],function(err,doc){
				if (err){
					reject(err);
				} else {
					resolve(document);
				}
			});
		});
	});
	return promise;
};


/* Create a panel from the input object (in JSON).
 * There are 3 types of panels, "gene", "coord", "marker":
 * 1) gene, 2) chromosomal coordinate, 3) marker
 * If specifying gene or marker panel, pass in a list of genes/markers 
 * (case insensitive):
 * [{"gene": "cyp2d6"}, {"gene": "tpmt"}, {"gene": "brca1"}, {"gene": "plce1"}]
 * or
 * [{"marker": rs1128503"}, {"marker": "rs2032582"}, {"marker": "rs1045642"}]
 * If specifying a coordinate panel, pass a list of objects (note chromosome
 * must be passed in as a string, coordinate as an integer):
 * [{"chr": "22", "coord": 4253023}, {"chr": "22", "coord": 4253028}]
 * Returns a promise which resolves to the new panel's collection ID. */
var addPanel= function(panelName, panel) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first
	
	// validate input
	assert(Object.prototype.toString.call(panelName) == "[object String]",
		"Invalid panel name");
	assert(Object.prototype.toString.call(panel) == "[object Array]",
		"Invalid panel");

	var currentPanelCollectionID= undefined;

	var promise= new Promise(function(resolve, reject) {
		/* Get most recent panel collection ID integer from the admin table
		 * and increment it. */
		findOne(dbConstants.ADMIN_COLLECTION_ID, {})
			.then(function(doc) {
				currentPanelCollectionID= doc[dbConstants.CURRENT_PANEL_INDEX_FIELD];
				// Add panel collection ID to panels collection
				currentDocument= {};
				currentDocument[dbConstants.PANEL_ID_FIELD]= panelName;
				currentDocument[dbConstants.COLLECTION_ID_FIELD]= "panel" + currentPanelCollectionID;
				return insert(dbConstants.PANELS_COLLECTION_ID, currentDocument);
			}).then(function(result) {
				// Create a new collection using the currentPanelCollectionID as the name
				// and store the input panel object.
				return new Promise(function(resolve, reject) {
					db.collection("panel" + currentPanelCollectionID, function(err, col) {
						var bulk= col.initializeUnorderedBulkOp();
						for (var i= 0; i < panel.length; ++i) {
							bulk.insert(panel[i]);
						}
						bulk.execute(function(err, doc) {
							if (err) {
								reject(err);
							} else {
								resolve(doc);
							}
						});
					});
				});
			}).then(function(result) {
				// Increment panel collection ID only after insert is done
				var currentDocument= {};
				currentDocument[dbConstants.CURRENT_PANEL_INDEX_FIELD]= 1;  // increment by 1
				return update(dbConstants.ADMIN_COLLECTION_ID, {}, {$inc: currentDocument});
			}).then(function(result) {
				// Promise resolves to the new panel's collection ID
				resolve(currentPanelCollectionID);
			}).catch(function(err) {
				console.log(err);
				reject(err);
			});
	});
	return promise;
};


/* Connect to the DB and initialize it using defaults if the DB has not been
 * initialized already. if silent exists, will not print to console.*/
var connectAndInitializeDB= function(silent) {
	var promise= new Promise(function(resolve, reject) {
		// Connect to MongoDB
		connect().then(function(result) {
			db= result;
			if (!silent)
				console.log("Connected to MongoDB at " + dbURL);

			/* Check if the "FrangipaniDB" DB already exists. If it doesn't, 
			 * we need to intialize the DB. */
			 count(dbConstants.SYSTEM_NAMESPACES).then(function(result) {
			 	if (!result) { // # of collections in DB is 0
			 		if (!silent){
			 			console.log("Initializing FrangipaniDB.");
			 		}
			 		createInitCollections()
			 			.catch(function(err) {
		 					reject(err);
		 				});
			 	} else {
			 		if (!silent)
			 			console.log("FrangipaniDB has already been initialized.");
			 	}
			 	resolve();
			 }).catch(function(err) {
			 	reject(err);
			 });
		}).catch(function(err) {
			reject(err);
		});
	});
	return promise;
};

/* Change or check if the server has been configured.
 * If changing the status of the configuration, use the set parameter.
 * set === true, changes the configured status to true.
 * If set is omitted, function returns the status as a boolean.
 * Returns a promise. */
var isConfigured= function(set) {
	assert.notStrictEqual(db, undefined); // ensure we're connected first
	assert(Object.prototype.toString.call(set) == "[object Boolean]"
		|| Object.prototype.toString.call(set) == "[object Undefined]",
		"Invalid config set parameter");

	var promise= new Promise(function(resolve, reject) {
		if (set === undefined) {  // Return config status
			findOne(dbConstants.ADMIN_COLLECTION_ID, {})
				.then(function(doc) {
					resolve(doc[dbConstants.SERVER_CONFIGURED_ID_FIELD]);
				}).catch(function(err) {
					reject(err);
				});
		} else { // set config status
			var currentDocument= {};
			currentDocument[dbConstants.SERVER_CONFIGURED_ID_FIELD]= set;
			update(dbConstants.ADMIN_COLLECTION_ID, {}, {$set: currentDocument})
				.then(function(doc) {
					resolve();
				}).catch(function(err) {
					reject(err);
				});
		}
	});
	return promise;
};


/* Create a new collection, raising an error if it already exists
 * returns a promise */

var createCollection = function(name){
	assert.notStrictEqual(db, undefined);


	var promise = new Promise(function(resolve,reject){
		if (name){
			db.createCollection(name,{strict:true},function(err,collection){
				if ( err ){
					reject(err);
				} else {
					resolve(collection);
				}
			});
		}
	});
	return promise
};

/* Drop a currently existing collection
 * returns a promise */
var dropCollection = function(collectionName){
	assert.notStrictEqual(db, undefined); 
	assert(Object.prototype.toString.call(collectionName) == "[object String]",
		"Invalid Options");

	var promise = new Promise(function(resolve,reject){
		db.dropCollection(collectionName, function(err,done){
			if (err){
				reject(err);
			} else {
				resolve(done);
			}
		});
	});
	return promise;
}

var findUserById = function(id){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(id) == "[object String]",
		"Invalid Options");
	var query = {};
	query[dbConstants.USER_ID_FIELD] = id;

	return findOne(dbConstants.USER_COLLECTION_ID,query);

};



var addUser = function(user){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(user[dbConstants.USER_ID_FIELD]) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(user[dbConstants.USER_PASSWORD_FIELD]) == "[object String]",
		"Invalid Options");
	//encrypt the password
	user[dbConstants.USER_PASSWORD_FIELD] = bcrypt.hashSync(user[dbConstants.USER_PASSWORD_FIELD], bcrypt.genSaltSync(8), null);
	return insert(dbConstants.USER_COLLECTION_ID,user);

};

var validatePassword = function(username,password){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(username) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(password) == "[object String]",
		"Invalid Options");

	return findUserById(username).then(function(result){
		 return bcrypt.compareSync(password, result[dbConstants.USER_PASSWORD_FIELD]);
	});

};


var findUserByGoogleId = function(id){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(id) == "[object String]",
		"Invalid Options");

	var query = {};
	query[dbConstants.USER_GOOGLE_ID_FIELD] = id;
	return findOne(dbConstants.USER_COLLECTION_ID,query);
};


var addUserGoogle = function(user){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(user[dbConstants.USER_GOOGLE_ID_FIELD]) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(user[dbConstants.USER_GOOGLE_TOKEN_FIELD]) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(user[dbConstants.USER_GOOGLE_NAME_FIELD]) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(user[dbConstants.USER_GOOGLE_EMAIL_FIELD]) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(user[dbConstants.USER_ID_FIELD]) == "[object String]",
		"Invalid Options");
	return insert(dbConstants.USER_COLLECTION_ID,user);
};

var generatePassword = function(user){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(user) == "[object String]",
		"Invalid Options");

	var newPassowrd = randomstring(10);
	var encryptPassword = bcrypt.hashSync(newPassowrd,bcrypt.genSaltSync(8),null);
	var query = {};
	query[dbConstants.USER_ID_FIELD] = user
	newPass = {}
	newPass[dbConstants.USER_PASSWORD_FIELD] = encryptPassword
	var doc = {$set:newPass};
	return update(dbConstants.USER_COLLECTION_ID,query,doc).then(function(result){
		return newPassowrd
	})
}

var changePassword = function(user, password){
	assert.notStrictEqual(db, undefined);
	assert(Object.prototype.toString.call(user) == "[object String]",
		"Invalid Options");
	assert(Object.prototype.toString.call(password) == "[object String]",
		"Invalid Options");

	var encryptPassword = bcrypt.hashSync(password,bcrypt.genSaltSync(8),null);
	var doc = {};
	var query = {}
	query[dbConstants.USER_ID_FIELD] = user;
	doc[dbConstants.USER_PASSWORD_FIELD] = encryptPassword;
	doc = {$set:doc};

	return update(dbConstants.USER_COLLECTION_ID,query,doc)

}

/* Find all PGx variants for a specific patient ID.
 * NOTE: patient ID is the user-specified ID, not the internal collection ID.
 * Returns a promise. */
var getPGXVariants= function(patientID) {
	assert.notStrictEqual(db, undefined);  // ensure we're connected first

	var query= {};
	query[dbConstants.PATIENT_ID_FIELD]= patientID;

	var promise= findOne(dbConstants.PATIENTS_COLLECTION_ID, query)
	.then(function(result) {
		// build search query
		var query= {};
		query["$or"]= []
		for (var marker in pgx.pgxCoordinates) {
			if (pgx.pgxCoordinates.hasOwnProperty(marker)) {
				(function() {
					var tempCoords= {}
					tempCoords[dbConstants.CHROMOSOME]= pgx.pgxCoordinates[marker]["chr"];
					tempCoords[dbConstants.START]= pgx.pgxCoordinates[marker]["pos"];
					query["$or"].push(tempCoords);
				})();
			}
		}

		var currentPatientCollectionID= result[dbConstants.COLLECTION_ID_FIELD];
		return find(currentPatientCollectionID, query, {"_id": 0}); // don't send internal _id field
	});
	return promise;
};

/* Assign desired objects to exports. */ 
exports.connectAndInitializeDB= connectAndInitializeDB;
exports.closeConnection= closeConnection;
exports.addPatient = addPatient;
exports.findAllPatients = findAllPatients;
exports.find=find;
exports.insertMany = insertMany;
exports.createCollection = createCollection;
exports.dropCollection = dropCollection;
exports.removePatient = removePatient;
exports.createIndex = createIndex;
exports.isConfigured= isConfigured;
exports.update= update;
exports.findAllPatientIds = findAllPatientIds;
exports.count = count;
exports.findUserById = findUserById;
exports.addUser = addUser;
exports.validatePassword = validatePassword;
exports.insert = insert;
exports.findUserByGoogleId = findUserByGoogleId;
exports.addUserGoogle = addUserGoogle;
exports.generatePassword = generatePassword;
exports.changePassword = changePassword;
exports.addPanel= addPanel;
exports.getPGXVariants= getPGXVariants;
exports.addProject = addProject;
exports.addProjectToPatient = addProjectToPatient;
exports.findAllProjects = findAllProjects;




