/* Node module for the annotaion, parsing and uploading of a vcf file to a
 * running database (currently set to mongodb). the input is first checked
 * to ensure proper file formats are uploaded, annoation paths are set
 * and the options provided are correct. Additionally currently the module
 * specifies the option table as a required option to provide a table name.
 * this will eventually be removed and changed to patientname with the table
 * name automatically being determined.
 *
 *
 * Written by Patrick Magee
*/
var Promise = require("bluebird");
//var db = require("../frangipani_node_modules/DB");
var fs = Promise.promisifyAll(require('fs')); 
var path = require("path");
var glob = Promise.promisifyAll(require("glob"));
var child_process=Promise.promisifyAll(require('child_process'));
var dbConstants = require('./mongodb_constants');
var dbFunctions = require('./mongodb_functions');
//var Parser = require('./parseVCF');


//Custom Errors for event handling
function InputError(message){
		this.name = "InputError";
		this.message = ( message || "" );
		Error.call(this);
		Error.captureStackTrace(this,this.constructor);
};
InputError.prototype = Object.create(Error.prototype);
InputError.prototype.constructor = InputError;

function AnnotationError(message){
		this.name = "AnnotationError";
		this.message = ( message || "" );
		Error.call(this);
		Error.captureStackTrace(this,this.constructor);
};
AnnotationError.prototype = Object.create(Error.prototype);
AnnotationError.prototype.constructor = AnnotationError;

function ParseError(message){
		this.name = "ParseError";
		this.message = ( message || "" );
		Error.call(this);
		Error.captureStackTrace(this,this.constructor);
};
ParseError.prototype = Object.create(Error.prototype);
ParseError.prototype.constructor = ParseError;

function AnnovarError(message){
	this.name = "AnnovarError";
	this.message = ( message || "" );
	Error.call(this);
	Error.captureStackTrace(this,this.constructor);
};
AnnovarError.prototype = Object.create(Error.prototype);
AnnovarError.prototype.constructor = AnnovarError;



/* annotateAndAddVariants:
 * Main function that facilitates the annotation of variants
 * as well as their addition to a databse. It takes a single parameter:
 * 'options' which is a js object that contains the following arguments:
 *
 * input: path to input file in vcf format. REQUIRED
 * patients: an array with objects corresponding to individual patients with a mapped table property
 * 
 */

function annotateAndAddVariants(options){
	//new promise to return
	var promise = new Promise(function(resolve,reject){
		var annovarPath, annodbStrin, dbusageString, 
			tempOutputFile,buildver,annovarIndex;
		var inputFile = path.resolve(options['input']);

		//Check to see whether input file exists and if annovarPath exists
		dbFunctions.find('admin',{},{'annovar-path':1,'annovar-dbs':1,'annovar-usage':1,'annovar-index':1,'genome-build':1})
		.then(function(result){
			annodbString = result[0]['annovar-dbs'].join(',');
			annovarPath = result[0]['annovar-path'];
			dbusageString = result[0]['annovar-usage'].join(',');
			annovarIndex = result[0]['annovar-index'];
			buildver = result[0]['genome-build'];

		}).then(function(){
			return fs.statAsync(inputFile)
		}).then(function(result){
			var newFile = inputFile.replace(/\(|\)/gi,"").replace(/\s/,"_");
			return fs.renameAsync(inputFile,newFile).then(function(){
				inputFile = newFile;
				tempOutputFile = inputFile + '.' + buildver + '_multianno.txt';
			});

		}).then(function(){
			return fs.statAsync(annovarPath);
		}).then(function(){
			return options['patients'];
		}).each(function(patient){
			//create newTable and raise exception oif tablname already exists
			var collectionName = patient[dbConstants['COLLECTION_ID_FIELD']];
			return dbFunctions.createCollection(collectionName);
		}).then(function(){
			var execPath = path.resolve(annovarPath + '/table_annovar.pl');
			var dbPath = path.resolve(annovarPath + "/humandb/");
			var annovarCmd = execPath
			var args = [
				inputFile,
				dbPath,
				'-buildver',
				buildver,
				'-operation',
				dbusageString,
				'-nastring',
				'.',
				'-protocol',
				annodbString,
				'-vcfinput'
			];

			//run annovar command as a child process
			var promise = new Promise(function(resolve,reject){
				var ps = child_process.spawn(annovarCmd, args);
				ps.on('error',function(err){
					console.log(err);
					reject(err);
				});
				ps.on('exit',function(code){
					if (code ==0){
						resolve(code);
					} else {
						reject(code);
					}
				});
			});
			return promise;
		}).then(function(){
			//check to ensure the tempOutFile was created
			return fs.statAsync(tempOutputFile);
		}).then(function(){
			var args = [tempOutputFile,JSON.stringify(options['patients'])];
			var promise = new Promise(function(resolve, reject){
				var returnValue;
				ps = child_process.fork('./frangipani_node_modules/parseVCF',args,{silent:true});
				ps.on('error',function(err){
					reject(err);
				});

				//retrieve the json array printed to stdout from ther ParseVCF
				ps.stdout.on('data',function(data){
					var string = data.toString('utf-8');
					returnValue = JSON.parse(string);
				});
				ps.stderr.on('data',function(data){
					console.log("ERR: " + data.toString('utf-8'));
				});
				ps.on('exit',function(code){
					if (code == 0){
						resolve(returnValue);
					} else {
						reject(code);
					}
				});
			});	
			return promise;
		}).then(function(result){
			//ensure the documents in the database have no data loss
			//by comparing the number of lines -1 in the original file
			//with a count of the number of lines in the database.
			//if even one of them is off, reject it.
			var countArray = result; // this is an array containing the number of ignored values for each file
			var args = ['-l',tempOutputFile];
			var promise = new Promise(function(resolve, reject){
				ps = child_process.spawn('wc',args);
				ps.on('error',function(err){
					reject(err);
				});

				//when the process returns data;
				ps.stdout.on('data',function(data){
					var string = data.toString('utf-8');
					//extract the number
					string = string.split(/\s+/);
					string = string.filter(function(item){
						if (!isNaN(item))
							return(item);
					});
					num = parseInt(string[0]);

					//for each patient, determing the count of documents ion the collection
					Promise.each(options['patients'],function(patient,index){
						patientid = patient['patient_id'];
						collectionid = patient[dbConstants.COLLECTION_ID_FIELD]
						return dbFunctions.count(collectionid).then(function(count){
							console.log(count);
							console.log(countArray[index]);
							if (count + countArray[index] !== num - 1) // if this is not equal, reject by throwing a new error
								reject(new Error('Num of docuemnts in patient: ' + patientid + ' does not match with original file!' ))
						});
					}).then(function(){
						//resolve and contine.
						resolve("correct");
					});
				});
			});
			return promise;		

		}).then(function(){
			return Promise.each(options['patients'],function(patient){
				return dbFunctions.createIndex(patient[dbConstants['COLLECTION_ID_FIELD']],{'chr':1,'start':1,'end':1}).then(function(){
					//add additional indexex
					Promise.each(annovarIndex,function(index){
						var indexOpts = {};
						indexOpts[index] = 1;
						return dbFunctions.createIndex(patient[dbConstants['COLLECTION_ID_FIELD']],indexOpts);
					});
				});
			});
		}).then(function(){
			//Update the patient table
			var patient_list = options['patients'].map(function(obj){
				return obj['patient_id'];
			});
			var query = {'patient_id':{$in:patient_list}};
			var documents = {$set:{'ready':true,'completed': new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '')}};
			var insOptions = {multi:true};
			return dbFunctions.update('patients', query,documents, insOptions);

		}).then(function(){
			resolve('completed Annotation and uploaded  entries');
		}).catch(AnnovarError,function(err){
			console.log(err.toString());
		}).catch(function(err){
			//Need more robust error handler here for solving issues
			console.log(err.toString());
		}).done(function(){
			//Cleanup, remove files and close db connection
			return glob.globAsync(inputFile + "*")
			.each(function(file){
				return fs.unlinkAsync(file);
			})
		});
	});
	
	return promise;
}

module.exports = annotateAndAddVariants

	
		








